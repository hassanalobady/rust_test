## Random Number Generator

This project implements Distributed Key Generation (DKG) protocol, which allows a group of participants to collectively generate a random value without relying on a trusted third party by useing the BLS12-381 curve in a distributed randomness protocol. 

![image](https://github.com/hassanalobady/rust_test/assets/19050553/8f6f11a6-44cb-44c4-8d9f-7deedb0fe9d1)

### distributed randomness protocol:
#### Generating Random Seeds:

1. Each player generates their own random seed using the generate_random_seeds function. The number of players is specified by num_players.

2. The random seed is generated as a Scalar value using the rand::Rng trait's gen method, which generates random bytes and converts them into a Scalar.

#### Computing Curve Points:

1. Each player computes their curve point using their random seed and the BLS12-381 curve.
2. The curve point is computed by multiplying the generator point of the curve (G1Projective::generator()) with the player's random seed.
3. The computed curve points are stored in a Vec<G1Projective> using the compute_curve_points function.

#### Generating Cryptographic Commitments:

1. Each player generates a cryptographic commitment using their curve point.
2. The commitment is generated by adding the generator point of the curve to the player's curve point.
3. The generated commitments are stored in a Vec<G1Projective> using the generate_commitments function.

#### Verifying Commitments:

1. All players verify the commitments made by each player.
2. The commitments are verified by checking that a randomly chosen challenge matches the equation for a valid commitment.
3. The verify_commitments function takes the commitments and curve points as input and checks the equation for each commitment using a randomly generated challenge.

#### Revealing Ciphertexts:

1. Each player reveals their ciphertexts, which are the curve points they generated.
2. The curve points are converted into a byte array using to_affine().to_compressed().to_bytes().
2. The revealed ciphertexts are stored in a byte array using the reveal_ciphertexts function.

#### Computing Final Randomness:
1. The compute_final_randomness function takes the ciphertexts as input and performs the XOR operation to compute the final randomness as a byte array.
